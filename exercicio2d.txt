Exercício 2 (d) — Comparação e Explicação
1. Comparação dos Resultados
Ao executar o código do item anterior (2c), observamos a seguinte saída:

Resultado da soma sequencial: 100
Resultado da soma paralela com reduction: 100
A comparação é direta: os resultados são idênticos. Isso prova que a nossa versão paralela, que utiliza a diretiva #pragma omp parallel for reduction(+:soma), calculou a soma de todos os elementos do vetor de forma correta e confiável.

2. Explicação: Por que a Diretiva reduction é Necessária?
A diretiva reduction é absolutamente crucial para garantir a exatidão do resultado em operações como esta. Sem ela, teríamos um problema grave chamado Condição de Corrida (Race Condition).

O Problema: Condição de Corrida (sem reduction)
Imagine que não usamos reduction e simplesmente pedimos para várias threads atualizarem a mesma variável soma compartilhada. Pense em duas threads, Thread A e Thread B, tentando somar seus valores. O processo desastroso seria o seguinte:

A variável soma na memória vale, digamos, 50.

Thread A lê o valor de soma. Ela carrega o valor 50 para seu registrador interno.

Thread B também lê o valor de soma. Como a Thread A ainda não escreveu o novo resultado, a Thread B também carrega o valor 50.

Thread A calcula: Ela adiciona seu valor (que é 1) ao que leu (50), e calcula o resultado 51.

Thread B calcula: Ela também adiciona seu valor (que é 1) ao que leu (50), e também calcula o resultado 51.

Thread A escreve o resultado de volta: A variável soma na memória agora vale 51.

Thread B escreve o resultado de volta: Ela também escreve 51 na memória, sobrescrevendo o valor que a Thread A acabou de colocar lá.

Resultado errado: O valor correto de soma deveria ser 50 + 1 + 1 = 52, mas por causa da "corrida" e da sobreposição de leituras e escritas, o resultado final foi 51. A contribuição de uma das threads foi perdida. Agora, imagine esse problema acontecendo milhares de vezes com várias threads. O resultado final seria imprevisível e completamente errado.

A Solução: Como o reduction Funciona
A cláusula reduction(+:soma) resolve este problema de forma elegante, eliminando a competição pela variável compartilhada.

Criação de Cópias Privadas: Em vez de todas as threads usarem a mesma variável soma original, o OpenMP cria uma cópia privada de soma para cada thread. Cada uma dessas cópias é inicializada com 0 (o valor inicial para uma soma).

Trabalho Independente: Cada thread percorre sua parte do laço for e atualiza apenas a sua própria cópia privada. Não há nenhuma interferência ou competição entre as threads durante o cálculo.

Combinação Final (Redução): Uma vez que todas as threads terminaram suas iterações, o OpenMP executa um passo final e seguro: ele pega os valores de todas as cópias privadas e os combina usando o operador especificado (+). O resultado dessa combinação final é então armazenado na variável soma original.

Em resumo, reduction é necessária porque ela estabelece um "ambiente de trabalho" seguro, onde as threads podem operar em paralelo sem risco de corromperem os dados umas das outras, garantindo que o resultado final seja matematicamente correto.